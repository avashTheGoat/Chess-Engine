/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.chess.engine;

import java.util.List;
import java.util.ArrayList;
import java.util.Random;

import com.github.bhlangonijr.chesslib.Board;
import com.github.bhlangonijr.chesslib.File;
import com.github.bhlangonijr.chesslib.Piece;
import com.github.bhlangonijr.chesslib.Side;
import com.github.bhlangonijr.chesslib.Square;
import com.github.bhlangonijr.chesslib.move.Move;

import org.apache.commons.lang3.mutable.MutableInt;

public class App
{
    private static final float SCORE_TOLERANCE = 0.01f;

    public static void main(String[] args)
    {
        Board _test = new Board();
        _test.loadFromFen("rnb1kbnr/pppp1pp1/4p2p/6q1/4P3/5N1P/PPPP1PP1/RNBQKB1R w KQkq - 0 1");
        System.out.println(_test.toString());
        System.out.println();

        System.out.println(_test.getFistPieceLocation(Piece.BLACK_KING));
        System.out.println();

        System.out.println("Depth 0 (short-sighted evaluation): ");
        System.out.println(Evaluate(_test));

        System.out.println("NO ALPHA-BETA PRUNING");
        System.out.println("_______________________________");
        MutableInt _numMoves = new MutableInt(0);
        System.out.println("Depth 1: ");
        System.out.println(FindBestMove(_test, _test.getSideToMove(), _test.getSideToMove(), 1, 0, null, _numMoves));
        System.out.println("Num moves evaluated: " + _numMoves.intValue());

        _numMoves = new MutableInt(0);
        System.out.println("Depth 2: ");
        System.out.println(FindBestMove(_test, _test.getSideToMove(), _test.getSideToMove(), 2, 0, null, _numMoves));
        System.out.println("Num moves evaluated: " + _numMoves.intValue());

        _numMoves = new MutableInt(0);
        System.out.println("Depth 3: ");
        System.out.println(FindBestMove(_test, _test.getSideToMove(), _test.getSideToMove(), 3, 0, null, _numMoves));
        System.out.println("Num moves evaluated: " + _numMoves.intValue());

        System.out.println("ALPHA-BETA PRUNING: ");
        System.out.println("______________________________________");
        _numMoves = new MutableInt(0);
        System.out.println("Depth 1: ");
        System.out.println(FindBestMove(_test, _test.getSideToMove(), _test.getSideToMove(), 1, 0, null, -Float.MAX_VALUE, Float.MAX_VALUE, _numMoves));
        System.out.println("Num moves evaluated: " + _numMoves.intValue());

        _numMoves = new MutableInt(0);
        System.out.println("Depth 2: ");
        System.out.println(FindBestMove(_test, _test.getSideToMove(), _test.getSideToMove(), 2, 0, null, -Float.MAX_VALUE, Float.MAX_VALUE, _numMoves));
        System.out.println("Num moves evaluated: " + _numMoves.intValue());

        _numMoves = new MutableInt(0);
        System.out.println("Depth 3: ");
        System.out.println(FindBestMove(_test, _test.getSideToMove(), _test.getSideToMove(), 3, 0, null, -Float.MAX_VALUE, Float.MAX_VALUE, _numMoves));
        System.out.println("Num moves evaluated: " + _numMoves.intValue());

        System.out.println("FINDING BEST LINE");
        System.out.println("_______________________________________");
        System.out.println("Depth 2 (Best line): ");
        System.out.println(FindBestLine(_test, _test.getSideToMove(), _test.getSideToMove(), 2, 0, null));
    
        System.out.println();
        _test.loadFromFen("rnbqkbnr/pppppppp/8/4P1P1/4P1P1/4P1P1/4P1P1/RNBQKBNR b KQkq - 0 1");
        
        System.out.println("Crazy pawn structure:");
        System.out.println(_test.toString());
        System.out.println();

        System.out.println("Depth 0: ");
        System.out.println(Evaluate(_test));
    }

    /**
     * Finds the best move using the Minimax algorithm.
     * @param _board the position of a Chess game
     * @param _initialPerspective the side whose turn it is
     * @param _curPerspective set as the same value as initial perspective
     * @param _maxDepth the depth (number of moves in the future) to calculate to
     * @param _depth set as 0
     * @param _rootMove set as null
     * @return the best move, along with the score of the move, for the side whose turn it is
     */
    private static ScoredMove FindBestMove(Board _board, Side _initialPerspective,
                                           Side _curPerspective, int _maxDepth, int _depth,
                                           ScoredMove _rootMove)
    {
        if (_board.isDraw()) return new ScoredMove(null, 0f);

        if (_board.isMated())
        {
            Square _whiteKingLocation = _board.getKingSquare(Side.WHITE);

            if (_board.squareAttackedBy(_whiteKingLocation, Side.BLACK) != 0L)
                return new ScoredMove(null, -Float.MAX_VALUE);

            else return new ScoredMove(null, Float.MAX_VALUE);
        }

        if (_depth == _maxDepth)
            return new ScoredMove(_maxDepth == 0 ? null : _rootMove.getMove(), Evaluate(_board));
        

        ScoredMove _bestMoveForSide = null;
        List<ScoredMove> _equalMoves = new ArrayList<>(0);
        for (Move _curMove : _board.legalMoves())
        {
            if (_depth == 0) _rootMove = new ScoredMove(_curMove, 0f);

            _board.doMove(_curMove);

            ScoredMove _scoredMove = FindBestMove
            (
                _board, _initialPerspective,
                _curPerspective == Side.WHITE ? Side.BLACK : Side.WHITE,
                _maxDepth, _depth + 1, _rootMove
            );

            _board.undoMove();

            if (_bestMoveForSide == null)
            {
                _bestMoveForSide = _scoredMove;
                _equalMoves.add(_scoredMove);
            }

            if (_scoredMove.getScore() + SCORE_TOLERANCE > _bestMoveForSide.getScore()
                && _scoredMove.getScore() - SCORE_TOLERANCE < _bestMoveForSide.getScore())
            {
                _equalMoves.add(_scoredMove);
            }

            else if (_curPerspective == Side.WHITE)
            {
                if (_scoredMove.getScore() > _bestMoveForSide.getScore())
                {
                    _bestMoveForSide = _scoredMove;
                    _equalMoves.clear();
                    _equalMoves.add(_scoredMove);
                }
            }

            else
            {
                if (_scoredMove.getScore() < _bestMoveForSide.getScore())
                {
                    _bestMoveForSide = _scoredMove;
                    _equalMoves.clear();
                    _equalMoves.add(_scoredMove);
                }
            }
        }

        // only if depth is zero because this method
        // only returns the root move, so this won't
        // affect the outcome for other depths
        if (_depth == 0 && _equalMoves.size() > 1)
        {
            int _randIndex = new Random().nextInt(_equalMoves.size());
            _rootMove = _equalMoves.get(_randIndex);
        }

        else if (_initialPerspective == Side.WHITE)
        {
            if (_bestMoveForSide.getScore() > _rootMove.getScore())
                _rootMove = new ScoredMove(_rootMove.getMove(), _bestMoveForSide.getScore());
        }

        else
        {
            if (_bestMoveForSide.getScore() < _rootMove.getScore())
                _rootMove = new ScoredMove(_rootMove.getMove(), _bestMoveForSide.getScore());
        }

        return _bestMoveForSide;
    }

    /**
     * Finds the best move using the Minimax algorithm.
     * In addition, the function "returns" the number of moves that were evaluated
     * using the org.apache.commons.lang3.mutable.MutableInt class.
     * @param _board the position of a Chess game
     * @param _initialPerspective the side whose turn it is
     * @param _curPerspective set as the same value as initial perspective
     * @param _maxDepth the depth (number of moves in the future) to calculate to
     * @param _depth set as 0
     * @param _rootMove set as null
     * @param _numMovesEvaluated an object holding the number of positions that were evaluated
     * while finding the best move
     * @return the best move, along with the score of the move, for the side whose turn it is
     */
    private static ScoredMove FindBestMove(Board _board, Side _initialPerspective,
                                           Side _curPerspective, int _maxDepth, int _depth,
                                           ScoredMove _rootMove, MutableInt _numMovesEvaluated)
    {
        if (_board.isDraw()) return new ScoredMove(null, 0f);

        if (_board.isMated())
        {
            Square _whiteKingLocation = _board.getKingSquare(Side.WHITE);

            if (_board.squareAttackedBy(_whiteKingLocation, Side.BLACK) != 0L)
                return new ScoredMove(null, -Float.MAX_VALUE);

            else return new ScoredMove(null, Float.MAX_VALUE);
        }

        if (_depth == _maxDepth)
        {
            if (_rootMove == null)
            {
                throw new IllegalArgumentException("Max depth cannot be zero.");
            }

            return new ScoredMove(_rootMove.getMove(), Evaluate(_board));
        }
        

        ScoredMove _bestMoveForSide = null;
        List<ScoredMove> _equalMoves = new ArrayList<>(0);
        for (Move _curMove : _board.legalMoves())
        {
            _numMovesEvaluated.increment();

            if (_depth == 0) _rootMove = new ScoredMove(_curMove, 0f);

            _board.doMove(_curMove);

            ScoredMove _scoredMove = FindBestMove
            (
                _board, _initialPerspective,
                _curPerspective == Side.WHITE ? Side.BLACK : Side.WHITE,
                _maxDepth, _depth + 1, _rootMove, _numMovesEvaluated
            );

            _board.undoMove();

            if (_bestMoveForSide == null)
            {
                _bestMoveForSide = _scoredMove;
                _equalMoves.add(_scoredMove);
            }

            if (_scoredMove.getScore() + SCORE_TOLERANCE > _bestMoveForSide.getScore()
                && _scoredMove.getScore() - SCORE_TOLERANCE < _bestMoveForSide.getScore())
            {
                _equalMoves.add(_scoredMove);
            }

            else if (_curPerspective == Side.WHITE)
            {
                if (_scoredMove.getScore() > _bestMoveForSide.getScore())
                {
                    _bestMoveForSide = _scoredMove;
                    _equalMoves.clear();
                    _equalMoves.add(_scoredMove);
                }
            }

            else
            {
                if (_scoredMove.getScore() < _bestMoveForSide.getScore())
                {
                    _bestMoveForSide = _scoredMove;
                    _equalMoves.clear();
                    _equalMoves.add(_scoredMove);
                }
            }
        }

        // only if depth is zero because this method
        // only returns the root move, so this won't
        // affect the outcome for other depths
        if (_depth == 0 && _equalMoves.size() > 1)
        {
            int _randIndex = new Random().nextInt(_equalMoves.size());
            _rootMove = _equalMoves.get(_randIndex);
        }

        else if (_initialPerspective == Side.WHITE)
        {
            if (_bestMoveForSide.getScore() > _rootMove.getScore())
                _rootMove = new ScoredMove(_rootMove.getMove(), _bestMoveForSide.getScore());
        }

        else
        {
            if (_bestMoveForSide.getScore() < _rootMove.getScore())
                _rootMove = new ScoredMove(_rootMove.getMove(), _bestMoveForSide.getScore());
        }

        return _bestMoveForSide;
    }

    /**
     * Finds the best move using the Minimax algorithm and alpha beta pruning.
     * @param _board the position of a Chess game
     * @param _initialPerspective the side whose turn it is
     * @param _curPerspective set as the same value as initial perspective
     * @param _maxDepth the depth (number of moves in the future) to calculate to
     * @param _depth set as 0
     * @param _rootMove set as null
     * @param _alpha set as -Float.MAX_VALUE
     * @param _beta set as Float.MAX_VALUE
     * @return the best move, along with the score of the move, for the side whose turn it is
     */
    private static ScoredMove FindBestMove(Board _board, Side _initialPerspective,
                                           Side _curPerspective, int _maxDepth, int _depth,
                                           ScoredMove _rootMove, float _alpha, float _beta)
    {
        if (_board.isDraw()) return new ScoredMove(null, 0f);

        if (_board.isMated())
        {
            Square _whiteKingLocation = _board.getKingSquare(Side.WHITE);

            if (_board.squareAttackedBy(_whiteKingLocation, Side.BLACK) != 0L)
                return new ScoredMove(null, -Float.MAX_VALUE);

            else return new ScoredMove(null, Float.MAX_VALUE);
        }

        if (_depth == _maxDepth)
            return new ScoredMove(_maxDepth == 0 ? null : _rootMove.getMove(), Evaluate(_board));

        ScoredMove _bestMoveForSide = new ScoredMove
        (
            new Move(Square.NONE, Square.NONE),
            _curPerspective == Side.WHITE ? -Float.MAX_VALUE : Float.MAX_VALUE
        );
        List<ScoredMove> _equalMoves = new ArrayList<>(0);
        for (Move _curMove : _board.legalMoves())
        {
            if (_depth == 0) _rootMove = new ScoredMove(_curMove, 0f);

            _board.doMove(_curMove);

            ScoredMove _scoredMove = FindBestMove
            (
                _board, _initialPerspective,
                _curPerspective == Side.WHITE ? Side.BLACK : Side.WHITE,
                _maxDepth, _depth + 1, _rootMove, _alpha, _beta
            );

            _board.undoMove();

            if (_bestMoveForSide == null)
            {
                _bestMoveForSide = _scoredMove;
                _equalMoves.add(_scoredMove);
            }

            if (_scoredMove.getScore() + SCORE_TOLERANCE > _bestMoveForSide.getScore()
                && _scoredMove.getScore() - SCORE_TOLERANCE < _bestMoveForSide.getScore())
            {
                _equalMoves.add(_scoredMove);
            }

            else if (_curPerspective == Side.WHITE)
            {
                if (_scoredMove.getScore() > _bestMoveForSide.getScore())
                {
                    _bestMoveForSide = _scoredMove;
                    _equalMoves.clear();
                    _equalMoves.add(_scoredMove);
                }

                _alpha = Math.max(_alpha, _bestMoveForSide.getScore());
                if (_alpha >= _beta)
                {
                    System.out.println("Pruning because black has a better option");
                    System.out.println("Alpha: " + _alpha);
                    System.out.println("Beta: " + _beta);
                    System.out.println("Best move for white so far: " + _bestMoveForSide);
                    break;
                }
            }

            else
            {
                if (_scoredMove.getScore() < _bestMoveForSide.getScore())
                {
                    _bestMoveForSide = _scoredMove;
                    _equalMoves.clear();
                    _equalMoves.add(_scoredMove);
                }

                _beta = Math.min(_beta, _bestMoveForSide.getScore());
                if (_beta <= _alpha)
                {
                    System.out.println("Pruning because white has a better option");
                    System.out.println("Beta: " + _beta);
                    System.out.println("Alpha: " + _alpha);
                    System.out.println("Best move for black so far: " + _bestMoveForSide);
                    break;
                }
            }
        }

        // only if depth is zero because this method
        // only returns the root move, so this won't
        // affect the outcome for other depths
        if (_depth == 0 && _equalMoves.size() > 1)
        {
            int _randIndex = new Random().nextInt(_equalMoves.size());
            _rootMove = _equalMoves.get(_randIndex);
        }

        else if (_initialPerspective == Side.WHITE)
        {
            if (_bestMoveForSide.getScore() > _rootMove.getScore())
                _rootMove = new ScoredMove(_rootMove.getMove(), _bestMoveForSide.getScore());
        }

        else
        {
            if (_bestMoveForSide.getScore() < _rootMove.getScore())
                _rootMove = new ScoredMove(_rootMove.getMove(), _bestMoveForSide.getScore());
        }

        return _bestMoveForSide;
    }

    /**
     * Finds the best move using the Minimax algorithm and alpha beta pruning.
     * In addition, the function "returns" the number of moves that were evaluated
     * using the org.apache.commons.lang3.mutable.MutableInt class.
     * @param _board the position of a Chess game
     * @param _initialPerspective the side whose turn it is
     * @param _curPerspective set as the same value as initial perspective
     * @param _maxDepth the depth (number of moves in the future) to calculate to
     * @param _depth set as 0
     * @param _rootMove set as null
     * @param _alpha set as -Float.MAX_VALUE
     * @param _beta set as Float.MAX_VALUE
     * @param _numMovesEvaluated an object holding the number of positions that were evaluated
     * while finding the best move
     * @return the best move, along with the score of the move, for the side whose turn it is
     */
    private static ScoredMove FindBestMove(Board _board, Side _initialPerspective,
                                           Side _curPerspective, int _maxDepth, int _depth,
                                           ScoredMove _rootMove, float _alpha, float _beta,
                                           MutableInt _numMovesEvaluated)
    {
        if (_board.isDraw()) return new ScoredMove(null, 0f);

        if (_board.isMated())
        {
            Square _whiteKingLocation = _board.getKingSquare(Side.WHITE);

            if (_board.squareAttackedBy(_whiteKingLocation, Side.BLACK) != 0L)
                return new ScoredMove(null, -Float.MAX_VALUE);

            else return new ScoredMove(null, Float.MAX_VALUE);
        }

        if (_depth == _maxDepth)
        {
            _numMovesEvaluated.increment();
            return new ScoredMove(_maxDepth == 0 ? null : _rootMove.getMove(), Evaluate(_board));
        }

        ScoredMove _bestMoveForSide = new ScoredMove
        (
            new Move(Square.NONE, Square.NONE),
            _curPerspective == Side.WHITE ? -Float.MAX_VALUE : Float.MAX_VALUE
        );
        List<ScoredMove> _equalMoves = new ArrayList<>(0);
        for (Move _curMove : _board.legalMoves())
        {
            if (_depth == 0) _rootMove = new ScoredMove(_curMove, 0f);

            _board.doMove(_curMove);

            ScoredMove _scoredMove = FindBestMove
            (
                _board, _initialPerspective,
                _curPerspective == Side.WHITE ? Side.BLACK : Side.WHITE,
                _maxDepth, _depth + 1, _rootMove, _alpha, _beta, _numMovesEvaluated
            );

            _board.undoMove();

            if (_bestMoveForSide == null)
            {
                _bestMoveForSide = _scoredMove;
                _equalMoves.add(_scoredMove);
            }

            if (_scoredMove.getScore() + SCORE_TOLERANCE > _bestMoveForSide.getScore()
                && _scoredMove.getScore() - SCORE_TOLERANCE < _bestMoveForSide.getScore())
            {
                _equalMoves.add(_scoredMove);
            }

            else if (_curPerspective == Side.WHITE)
            {
                if (_scoredMove.getScore() > _bestMoveForSide.getScore())
                {
                    _bestMoveForSide = _scoredMove;
                    _equalMoves.clear();
                    _equalMoves.add(_scoredMove);
                }

                _alpha = Math.max(_alpha, _bestMoveForSide.getScore());
                if (_alpha >= _beta)
                {
                    // System.out.println("Pruning because black has a better option");
                    // System.out.println("Alpha: " + _alpha);
                    // System.out.println("Beta: " + _beta);
                    // System.out.println("Best move for white so far: " + _bestMoveForSide);
                    break;
                }
            }

            else
            {
                if (_scoredMove.getScore() < _bestMoveForSide.getScore())
                {
                    _bestMoveForSide = _scoredMove;
                    _equalMoves.clear();
                    _equalMoves.add(_scoredMove);
                }

                _beta = Math.min(_beta, _bestMoveForSide.getScore());
                if (_beta <= _alpha)
                {
                    // System.out.println("Pruning because white has a better option");
                    // System.out.println("Beta: " + _beta);
                    // System.out.println("Alpha: " + _alpha);
                    // System.out.println("Best move for black so far: " + _bestMoveForSide);
                    break;
                }
            }
        }

        // only if depth is zero because this method
        // only returns the root move, so this won't
        // affect the outcome for other depths
        if (_depth == 0 && _equalMoves.size() > 1)
        {
            int _randIndex = new Random().nextInt(_equalMoves.size());
            _rootMove = _equalMoves.get(_randIndex);
        }

        else if (_initialPerspective == Side.WHITE)
        {
            if (_bestMoveForSide.getScore() > _rootMove.getScore())
                _rootMove = new ScoredMove(_rootMove.getMove(), _bestMoveForSide.getScore());
        }

        else
        {
            if (_bestMoveForSide.getScore() < _rootMove.getScore())
                _rootMove = new ScoredMove(_rootMove.getMove(), _bestMoveForSide.getScore());
        }

        return _bestMoveForSide;
    }

    // TODO: fix this method (returns correct score, but it doesn't return the actual line)
    private static ScoredLine FindBestLine(Board _board, Side _initialPerspective,
                                                 Side _curPerspective, int _maxDepth, int _depth,
                                                 ScoredLine _curLine)
    {
        if (_board.isDraw())
        {
            _curLine = new ScoredLine(_curLine.getLine(), 0f);
            return _curLine;
        }

        if (_board.isMated())
        {
            Square _whiteKingLocation = _board.getKingSquare(Side.WHITE);

            // white is mated
            if (_board.squareAttackedBy(_whiteKingLocation, Side.BLACK) != 0L)
            {
                _curLine = new ScoredLine(_curLine.getLine(), -Float.MAX_VALUE);
                return _curLine;
            }

            // black is mated
            else
            {
                _curLine = new ScoredLine(_curLine.getLine(), Float.MAX_VALUE);
                return _curLine;
            }
        }

        if (_depth == _maxDepth)
        {
            if (_curLine == null)
            {
                throw new IllegalArgumentException("Max depth cannot be zero.");
            }

            return new ScoredLine(_curLine.getLine(), Evaluate(_board));
        }
        

        ScoredLine _bestLineForSide = null;
        List<ScoredLine> _equalLines = new ArrayList<>(0);
        for (Move _curMove : _board.legalMoves())
        {
            _board.doMove(_curMove);

            if (_curLine == null) _curLine = new ScoredLine(new ArrayList<>(), 0f);

            List<Move> _newLine = _curLine.getLine();
            _newLine.add(_curMove);

            _curLine = new ScoredLine(_newLine, _curLine.getScore());

            ScoredLine _scoredLine = FindBestLine
            (
                _board, _initialPerspective,
                _curPerspective == Side.WHITE ? Side.BLACK : Side.WHITE,
                _maxDepth, _depth + 1, _curLine
            );

            _board.undoMove();

            if (_bestLineForSide == null)
            {
                _bestLineForSide = _scoredLine;
                _equalLines.add(_scoredLine);
            }

            if (_scoredLine.getScore() + SCORE_TOLERANCE > _bestLineForSide.getScore()
                && _scoredLine.getScore() - SCORE_TOLERANCE < _bestLineForSide.getScore())
            {
                _equalLines.add(_scoredLine);
            }

            else if (_curPerspective == Side.WHITE)
            {
                if (_scoredLine.getScore() > _bestLineForSide.getScore())
                {
                    _bestLineForSide = _scoredLine;
                    _equalLines.clear();
                    _equalLines.add(_scoredLine);
                }
            }

            else
            {
                if (_scoredLine.getScore() < _bestLineForSide.getScore())
                {
                    _bestLineForSide = _scoredLine;
                    _equalLines.clear();
                    _equalLines.add(_scoredLine);
                }
            }
        }

        if (_equalLines.size() > 1)
        {
            int _randIndex = new Random().nextInt(_equalLines.size());
            return _equalLines.get(_randIndex);
        }
        
        return _bestLineForSide;
    }


    /**
     * Evaluates the position of a Chess board.
     * @param _board the position of a Chess game
     * @return the evaluation of the position. A negative number indicates a position
     * that favors the black side, while a positive number indicates a position that favors the white side.
     */
    private static float Evaluate(Board _board)
    {
        List<Square> _whitePawnLocations = _board.getPieceLocation(Piece.WHITE_PAWN);
        List<Square> _whiteKnightLocations = _board.getPieceLocation(Piece.WHITE_KNIGHT);
        List<Square> _whiteBishopLocations = _board.getPieceLocation(Piece.WHITE_BISHOP);
        List<Square> _whiteRookLocations = _board.getPieceLocation(Piece.WHITE_ROOK);
        Square _whiteQueenLocation = _board.getFistPieceLocation(Piece.WHITE_QUEEN);
        Square _whiteKingLocation = _board.getFistPieceLocation(Piece.WHITE_KING);
        boolean _isThereWhiteQueen = _whiteQueenLocation != Square.NONE;

        float _whiteMaterial = EvaluateMaterial
        (
            _whitePawnLocations.size(), _whiteKnightLocations.size(),
            _whiteBishopLocations.size(), _whiteRookLocations.size(),
            _isThereWhiteQueen ? 1 : 0
        );

        float _whitePosition = EvaluatePosition
        (
            _board, _whitePawnLocations, _whiteKnightLocations,
            _whiteBishopLocations, _whiteRookLocations, _whiteQueenLocation,
            _whiteKingLocation
        );

        List<Square> _blackPawnLocations = _board.getPieceLocation(Piece.BLACK_PAWN);
        List<Square> _blackKnightLocations = _board.getPieceLocation(Piece.BLACK_KNIGHT);
        List<Square> _blackBishopLocations = _board.getPieceLocation(Piece.BLACK_BISHOP);
        List<Square> _blackRookLocations = _board.getPieceLocation(Piece.BLACK_ROOK);
        Square _blackQueenLocation = _board.getFistPieceLocation(Piece.BLACK_QUEEN);
        Square _blackKingLocation = _board.getFistPieceLocation(Piece.BLACK_KING);
        boolean _isThereBlackQueen = _blackQueenLocation != Square.NONE;

        float _blackMaterial = EvaluateMaterial
        (
            _blackPawnLocations.size(), _blackKnightLocations.size(),
            _blackBishopLocations.size(), _blackRookLocations.size(),
            _isThereBlackQueen ? 1 : 0
        );

        float _blackPosition = EvaluatePosition
        (
            _board, _blackPawnLocations, _blackKnightLocations,
            _blackBishopLocations, _blackRookLocations, _blackQueenLocation,
            _blackKingLocation
        );

        // System.out.println();
        // System.out.println("White position, material: " + _whitePosition + ", " + _whiteMaterial);
        // System.out.println("Black position: " + _blackPosition + ", " + _blackMaterial);
        // System.out.println();
        // _whitePosition = 0f;
        // _blackPosition = 0f;

        return (_whiteMaterial + _whitePosition) - (_blackMaterial + _blackPosition);
    }

    /**
     * Evaluates the material value of pawns and pieces.
     * This function does not accept a board and a side to evaluate
     * to optimize the "Evaluate" function. The number of pawns and pieces should
     * be counted from the same side, position, and board.
     * @param _numPawns the number of pawns for a side. Should be 8 to 0.
     * @param _numKnights the number of knights for a side. Should be 2 to 0.
     * @param _numBishops the number of bishops for a side. Should be 2 to 0.
     * @param _numRooks the number of rooks for a side. Should be 2 to 0.
     * @param _queenNum the number of queens. Should be 1 or 0.
     * @return the counted-up material. A negative number indicates a position
     * that favors the black side, while a positive number indicates a position that favors the white side.
     */
    private static float EvaluateMaterial(int _numPawns, int _numKnights, int _numBishops,
    int _numRooks, int _queenNum)
    {
        final float PAWN_VALUE = 1f;
        final float KNIGHT_VALUE = 2.85f;
        final float BISHOP_VALUE = 3f;
        final float ROOK_VALUE = 5f;
        final float QUEEN_VALUE = 10f;

        float _totalMaterialValue = PAWN_VALUE * _numPawns + KNIGHT_VALUE * _numKnights
        + BISHOP_VALUE * _numBishops + ROOK_VALUE * _numRooks + QUEEN_VALUE * _queenNum;

        return _totalMaterialValue;
    }

    /**
     * Evaluates the positional aspect of a Chess board by calling functions such as
     * "EvaluatePiecePlacement", "EvaluatePawnStructure", and more internally.
     * The function takes in the pawn and piece location parameters to optimize
     * the "Evaluate" function.
     * <p>
     * These parameters should be counted from the same side, position, and board.
     * If there are no pawns, knights, bishops, or rooks, pass in an empty list.
     * If there is no queen or king, pass in "Square.NONE" as the value.
     * @param _board the position of a Chess game
     * @param _pawnLocations the locations of every pawn of a side
     * @param _knightLocations the locations of every knight of a side
     * @param _bishopLocations the locations of every bishop of a side
     * @param _rookLocations the locations of every rook of a side
     * @param _queenLocation the location of the queen of a side
     * @param _kingLocation the locations of every pawn of a side
     * @return the evaluation of the board for a side based on its positional aspects. A negative number indicates a position
     * that favors the black side, while a positive number indicates a position that favors the white side.
     */
    private static float EvaluatePosition(Board _board, List<Square> _pawnLocations,
    List<Square> _knightLocations, List<Square> _bishopLocations,
    List<Square> _rookLocations, Square _queenLocation, Square _kingLocation)
    {
        return EvaluatePiecePlacement
        (
            _pawnLocations, _knightLocations,
            _bishopLocations, _rookLocations, _queenLocation, _kingLocation
        )
        + EvaluatePieceMobility
        (
            _board, _knightLocations,
            _bishopLocations, _rookLocations, _queenLocation
        )
        + EvaluatePawnStructure(_pawnLocations) + EvaluateKingSafety(_board, _kingLocation);
    }

    // TODO
    private static float EvaluatePiecePlacement(List<Square> _pawnLocations,
    List<Square> _knightLocations, List<Square> _bishopLocations,
    List<Square> _rookLocations, Square _queenLocation, Square _kingLocation)
    {
        return 0f;
    }

    // TODO
    private static float EvaluatePieceMobility(Board _board,  List<Square> _knightLocations,
    List<Square> _bishopLocations, List<Square> _rookLocations, Square _queenLocation)
    {
        return 0f;
    }

    /**
     * Evaluates the pawn structure of a side.
     * <p>
     * The pawn locations should be counted from the same side, position, and board.
     * The function takes in the pawn locations to optimize the "Evaluation" function.
     * @param _pawnLocations the locations of every pawn of a side
     * @return the evaluation of the pawn structure of a side. A negative number indicates a position
     * that favors the black side, while a positive number indicates a position that favors the white side.
     */
    private static float EvaluatePawnStructure(List<Square> _pawnLocations)
    {
        final float DOUBLED_PAWN_PENALTY = 0.1f;
        final float ISOLATED_PAWN_PENALTY = 0.125f;
        final float DOUBLED_AND_ISOLATED_PENALTY = 0.115f;

        float _pawnStructurePenalty = 0f;

        // so that n doubled pawns in the same
        // file only get points deducted for each
        // of them rather than applying penalties
        // n * (n - 1) times
        boolean[] _doubledPawnFiles = new boolean[8];

        for (int i = 0; i < _pawnLocations.size(); i++)
        {
            int _numDoubledPawns = 0;
            boolean _isIsolated = true;

            File _pawnFile = _pawnLocations.get(i).getFile();

            for (int j = 0; j < _pawnLocations.size(); j++)
            {
                if (j == i) continue;

                File _comparingPawnFile = _pawnLocations.get(j).getFile();

                if (_pawnFile.equals(_comparingPawnFile) && !_doubledPawnFiles[_pawnFile.ordinal()])
                {
                    _numDoubledPawns++;
                    _doubledPawnFiles[_pawnFile.ordinal()] = true;
                }

                else if (_pawnFile.ordinal() + 1 == _comparingPawnFile.ordinal()
                         || _pawnFile.ordinal() - 1 == _comparingPawnFile.ordinal())
                    _isIsolated = false;
            }

            // +1 to count for itself
            _pawnStructurePenalty -= (_numDoubledPawns + 1) * DOUBLED_PAWN_PENALTY;
            _pawnStructurePenalty -= _isIsolated ? ISOLATED_PAWN_PENALTY : 0f;

            if (_numDoubledPawns > 0 && _isIsolated)
                _pawnStructurePenalty -= DOUBLED_AND_ISOLATED_PENALTY;
        }

        return _pawnStructurePenalty;
    }

    // TODO
    private static float EvaluateKingSafety(Board _board, Square _kingLocation)
    {
        return 0f;
    }
}